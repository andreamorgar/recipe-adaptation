# -*- coding: utf-8 -*-
"""results_word_embeddings.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qLUh_bcEqSrnsw_rMCO8qbHSOaUWSA7p
"""

from gensim.models import Word2Vec
from gensim.models import KeyedVectors
import pandas as pd
import ast


sst_home = '../data/'
sst_models = '../models/v2/'

def get_first(element):
    first_element = ast.literal_eval(element)[0]
    return " ".join(first_element)

def get_third(element):
    res = ast.literal_eval(element)[0:3]
    res = [" ".join(i) for i in res]
    return res

def get_second(element):
    res = ast.literal_eval(element)[0:2]
    res = [" ".join(i) for i in res]
    return res

def get_first_value(element):
    if 'inf' in element:
        return 1
    else:
        return ast.literal_eval(element)[0]

# load results with each word embedding model
df_mapping_w2v = pd.read_excel(sst_home + "results_w2v_14_ene.xlsx")
df_mapping_w2v = df_mapping_w2v.set_index('ingredients')
print(df_mapping_w2v.head())

df_mapping_ft = pd.read_excel(sst_home + "results_ft_14_ene.xlsx")
df_mapping_ft = df_mapping_ft.set_index('ingredients')
print(df_mapping_ft.head())

df_mapping_glove = pd.read_excel(sst_home + "results_glove_14_ene.xlsx")
df_mapping_glove = df_mapping_glove.set_index('ingredients')
print(df_mapping_glove.head())

# we concat the result to work with one unique dataframe
result = pd.concat([df_mapping_w2v, df_mapping_ft, df_mapping_glove], axis=1, join="inner")

result.head()
# dataframe preprocessing
print(len(result))

# result = pd.read_excel(sst_home + "result.xlsx")
result['best_w2v'] = result.mapping_w2v.apply(get_first)
result['best3_w2v'] = result.mapping_w2v.apply(get_third)
result['best2_w2v'] = result.mapping_w2v.apply(get_second)
result['best_w2v_value'] = result.values_w2v.apply(get_first_value)

result['best_ft'] = result.mapping_fasttext.apply(get_first)
result['best3_ft'] = result.mapping_fasttext.apply(get_third)
result['best2_ft'] = result.mapping_fasttext.apply(get_second)
result['best_ft_value'] = result.values_fasttext.apply(get_first_value)

result['best_glove'] = result.mapping_glove.apply(get_first)
result['best3_glove'] = result.mapping_glove.apply(get_third)
result['best2_glove'] = result.mapping_glove.apply(get_second)
result['best_glove_value'] = result.values_glove.apply(get_first_value)

result.head()

# result = result[(result['best_w2v_value'] != 1) & (result['best_ft_value'] != 1) ]
result = result[(result['best_w2v_value'] != 1)]
result = result[(result['best_ft_value'] != 1)]
result = result[(result['best_glove_value'] != 1)]

#result = result[(result['best_w2v_value'] <0.45) & (result['best_ft_value'] <0.45) ]
result_equals = result[result['best_w2v'] == result['best_ft'] ]

# if the best of w2v is in the best 3 of of the other model
def check(element):
  if element.best_w2v in element.best3_ft and element.best_ft in element.best3_w2v:
      return True
  else:
      return False

def check2(element):
    if element.best_w2v in element.best2_ft and element.best_ft in element.best2_w2v:
        return True
    else:
        return False

result['contained'] = result.apply(check,axis = 1)
result_contained = result[result['contained'] == True]

import numpy as np
equals_list = []
ii = []
equals_contained_list = []
equals_contained_2_list = []
total = []
for i in np.arange(0.001,0.5,0.01):
    result_div = result[(result['best_w2v_value'] <i) & (result['best_ft_value'] <i) ]
    total.append(len(result_div))

    result_equals = result_div[result_div['best_w2v'] == result_div['best_ft'] ]
    equals_list.append(len(result_equals))

    result_div['contained'] = result_div.apply(check,axis = 1)
    result_contained = result_div[result_div['contained'] == True]
    equals_contained_list.append(len(result_contained))

    result_div['contained_2'] = result_div.apply(check2,axis = 1)
    result_contained_2 = result_div[result_div['contained_2'] == True]
    equals_contained_2_list.append(len(result_contained_2))

    ii.append(i)

#%%
print(len(result))
import matplotlib.pyplot as plt
plt.xlabel('distance', fontsize=14)
plt.ylabel('number of coincident mappings', fontsize=14)

plt.plot(ii,total ,marker='o', markerfacecolor='darkgreen', markersize=4, color='lightgreen', linewidth=2, label="total of mappings")
plt.plot(ii,equals_contained_list,marker='o', markerfacecolor='red', markersize=4, color='orange', linewidth=2, label="mapping in best three")
plt.plot(ii,equals_contained_2_list,marker='o', markerfacecolor='black', markersize=4, color='gray', linewidth=2, label="mapping in best two")
plt.plot(ii,equals_list,marker='o', markerfacecolor='blue', markersize=4, color='skyblue', linewidth=2, label="best mapping match")
plt.legend(loc="upper left",fontsize=13.5)
plt.rc('xtick',labelsize=14)
plt.rc('ytick',labelsize=14)
plt.title("Equivalent mappings (Word2vec vs FastText)",fontsize=15.5) 

plt.savefig(sst_home + 'w2vec_vs_fasttext.png', dpi=150)


#%%
equals_list = []
ii = []
equals_contained_list = []
total = []
for i in np.arange(0.001,0.5,0.01):
    result_div = result[(result['best_glove_value'] <i) & (result['best_ft_value'] <i) ]
    total.append(len(result_div))

    result_equals = result_div[result_div['best_glove'] == result_div['best_ft'] ]
    equals_list.append(len(result_equals))

    result_div['contained'] = result_div.apply(check,axis = 1)
    result_contained = result_div[result_div['contained'] == True]
    equals_contained_list.append(len(result_contained))
    ii.append(i)
#%%
plt.xlabel('distance', fontsize=14)
plt.ylabel('number of coincident mappings', fontsize=14)
plt.plot(ii,total ,marker='o', markerfacecolor='darkgreen', markersize=4, color='lightgreen', linewidth=2, label="total of mappings")
plt.plot(ii,equals_contained_list,marker='o', markerfacecolor='red', markersize=4, color='orange', linewidth=2, label="mapping in best three")
plt.plot(ii,equals_contained_2_list,marker='o', markerfacecolor='black', markersize=4, color='gray', linewidth=2, label="mapping in best two")
plt.plot(ii,equals_list,marker='o', markerfacecolor='blue', markersize=4, color='skyblue', linewidth=2, label="best mapping match")
plt.legend(loc="upper left",fontsize=13.5)
plt.rc('xtick',labelsize=14)
plt.rc('ytick',labelsize=14)
plt.title("Equivalent mappings (GloVe vs FastText)",fontsize=15.5) 

plt.savefig(sst_home + 'glove_vs_fasttext.png', dpi=150)
#%%

equals_list = []
ii = []
equals_contained_list = []
total = []
for i in np.arange(0.001,0.5,0.01):
    result_div = result[(result['best_glove_value'] <i) & (result['best_w2v_value'] <i) ]
    total.append(len(result_div))

    result_equals = result_div[result_div['best_glove'] == result_div['best_w2v'] ]
    equals_list.append(len(result_equals))

    result_div['contained'] = result_div.apply(check,axis = 1)
    result_contained = result_div[result_div['contained'] == True]
    equals_contained_list.append(len(result_contained))
    ii.append(i)

#%%
plt.xlabel('distance', fontsize=14)
plt.ylabel('number of coincident mappings', fontsize=14)
plt.plot(ii,total ,marker='o', markerfacecolor='darkgreen', markersize=4, color='lightgreen', linewidth=2, label="total of mappings")
plt.plot(ii,equals_contained_list,marker='o', markerfacecolor='red', markersize=4, color='orange', linewidth=2, label="mapping in best three")
plt.plot(ii,equals_contained_2_list,marker='o', markerfacecolor='black', markersize=4, color='gray', linewidth=2, label="mapping in best two")
plt.plot(ii,equals_list,marker='o', markerfacecolor='blue', markersize=4, color='skyblue', linewidth=2, label="best mapping match")
#plt.ylim([0, 110]) 
#plt.hlines(y = 772, xmin=0, xmax=0.5 ,linestyle='dashed',color='gray', linewidth=1)
plt.legend(loc="upper left",fontsize=13.5)
plt.rc('xtick',labelsize=14.0)
plt.rc('ytick',labelsize=14.0)
plt.title("Equivalent mappings (GloVe vs Word2vec)",fontsize=15.5) 
plt.savefig(sst_home + 'glove_vs_w2v.png', dpi=150)

#%%
# kappa 1vs1

from sklearn.metrics import cohen_kappa_score
cohen_kappa_score(list(result['best_w2v']), list(result['best_glove']))

cohen_kappa_score(list(result['best_w2v']), list(result['best_ft']))

cohen_kappa_score(list(result['best_ft']), list(result['best_glove']))
#%%
from nltk import agreement

# we obtain Fleiss kappa between the three models
coder1 = list(result['best_w2v'])
coder2 = list(result['best_ft'])
coder3 = list(result['best_glove'])

formatted_codes = [[1,i,coder1[i]] for i in range(len(coder1))] + [[2,i,coder2[i]] for i in range(len(coder2))]  + [[3,i,coder3[i]] for i in range(len(coder3))]


ratingtask = agreement.AnnotationTask(data=formatted_codes)

print('Fleiss\'s Kappa:',ratingtask.multi_kappa())
print('Krippendorff\'s alpha:',ratingtask.alpha())
print('Scott\'s pi:',ratingtask.pi())


# percetage_agreement = (len(result[(result['best_w2v'] == result['best_ft'])])/len(result))*100
# print('Percentage of agreement:',percetage_agreement)

r = result['best_w2v_value'] - result['best_glove_value']

result.head()

np.array(result['best_ft_value'])

"""Fleiss's Kappa: 0.624885205206788
Krippendorff's alpha: 0.6242742329246845
Scott's pi: 0.6241431810352268
Percentage of agreement: 52.928870292887034
"""